
#include <jsk_mbzirc_tasks/track_region_extractor.h>

TrackRegionExtractor::TrackRegionExtractor() {
    this->onInit();
}

void TrackRegionExtractor::onInit() {
    this->subscribe();
    this->pub_image_ = pnh_.advertise<sensor_msgs::Image>(
        "target", 1);
}

void TrackRegionExtractor::subscribe() {
    this->sub_image_ = this->pnh_.subscribe(
        "input", 1, &TrackRegionExtractor::callback, this);
}

void TrackRegionExtractor::unsubscribe() {
    this->sub_image_.shutdown();
}

void TrackRegionExtractor::callback(
    const sensor_msgs::Image::ConstPtr &image_msg) {
    cv_bridge::CvImagePtr cv_ptr;
    try {
        cv_ptr = cv_bridge::toCvCopy(
            image_msg, sensor_msgs::image_encodings::BGR8);
    }
    catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }
    cv::Mat image = cv_ptr->image.clone();

    std::cout << "image_size" << image.size()  << "\n";
    
    cv::cuda::GpuMat d_image(image);
    cv::cuda::cvtColor(d_image, d_image, CV_BGR2GRAY);
    cv::cuda::GpuMat d_edge;
    double low_thresh = 50.0;
    double high_thresh = 100.0;
    cv::Ptr<cv::cuda::CannyEdgeDetector> canny_edge =
        cv::cuda::createCannyEdgeDetector(low_thresh, high_thresh, 3, true); 
    canny_edge->detect(d_image, d_edge);
    cv::Mat edges;
    d_edge.download(edges);

    std::cout << edges.type()  << "\n";
    
    approxTrackShape(edges);
    
    cv_bridge::CvImagePtr pub_msg(new cv_bridge::CvImage);
    pub_msg->header = image_msg->header;
    pub_msg->encoding = sensor_msgs::image_encodings::MONO8;
    pub_msg->image = edges.clone();
    this->pub_image_.publish(pub_msg);
}

void TrackRegionExtractor::approxTrackShape(cv::Mat &edges) {
    if (edges.empty()) {
        return;
    }    
    std::vector<std::vector<cv::Point> > contours;
    std::vector<cv::Vec4i> hierarchy;
    cv::findContours(edges, contours, hierarchy,
                     cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);
    
    cv::Mat tmp_img = cv::Mat::zeros(edges.size(), CV_8UC3);
    cv::RNG rng(12345);
    
    std::vector<std::vector<cv::Point> > poly(
        static_cast<int>(contours.size()));
    for (int i = 0; i < contours.size(); i++) {
        cv::approxPolyDP(cv::Mat(contours[i]), poly[i], 3, true);

        cv::Scalar color = cv::Scalar(rng.uniform(0, 255),
                                      rng.uniform(0,255),
                                      rng.uniform(0,255));
        cv::drawContours(tmp_img, poly, i, color, 2,
                         8, hierarchy, 0, cv::Point());
    }

    std::cout << "contours size: " << contours.size()  << "\n";
    
    cv::imshow("poly", tmp_img);
    cv::waitKey(3);
}

int main(int argc, char *argv[]) {
    ros::init(argc, argv, "jsk_mbzirc_tasks");
    TrackRegionExtractor ed;
    ros::spin();
    return 0;
}
